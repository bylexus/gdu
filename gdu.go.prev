package main

import (
	"fmt"
	"io/fs"
	"io/ioutil"
	"os"
	"path/filepath"
	"sync"
)

type filelike interface {
	getPath() string
	getByteSize() uint64
}

type file struct {
	relPath   string
	sizeBytes uint64
}

func (f file) getPath() string {
	return f.relPath
}

func (f file) getByteSize() uint64 {
	return f.sizeBytes
}

type dir struct {
	relPath        string
	totalSizeBytes uint64
	children       []*filelike
}

func (d dir) getPath() string {
	return d.relPath
}

func (d dir) getByteSize() uint64 {
	return d.totalSizeBytes
}

func examinePath(path string) (*filelike, error) {
	var ret filelike
	var files []fs.FileInfo

	fileInfo, err := os.Stat(path)
	if err != nil {
		return nil, err
	}

	if fileInfo.IsDir() {
		wg := sync.WaitGroup{}
		ch := make(chan *filelike, 1)

		d := dir{
			relPath:        path,
			totalSizeBytes: 0,
			children:       make([]*filelike, 0),
		}
		files, err = ioutil.ReadDir(path)
		wg.Add(len(files))
		for _, file := range files {
			go func(f string, w *sync.WaitGroup, c chan *filelike) {
				child, e2 := examinePath(f)
				if e2 == nil {
					c <- child
				}
				w.Done()
			}(filepath.Join(path, file.Name()), &wg, ch)
		}
		go func() {
			wg.Wait()
			close(ch)
		}()
		for res := range ch {
			d.totalSizeBytes += (*res).getByteSize()
			d.children = append(d.children, res)
		}
		ret = d
	} else {
		ret = file{
			relPath:   path,
			sizeBytes: uint64(fileInfo.Size()),
		}
	}

	return &ret, nil
}

func main() {
	searchPaths := []string{
		// "/Users/alex/SynologyDrive",
		"/Users/alex/dev",
		// "../../vms",
		// "/Users/alex/temp",
	}
	total := uint64(0)

	for _, path := range searchPaths {
		ret, err := examinePath(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
		} else {
			total += (*ret).getByteSize()
			fmt.Printf("%s: %v\n", path, (*ret).getByteSize())
		}
	}
	fmt.Printf("Total: %v\n", total)
}
